<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Fireworks Wall • HH Finale (Pure Firework) • Replay • Smooth</title>
  <style>
    html,body{margin:0;height:100%;overflow:hidden;background:#05060a;}
    canvas{display:block;width:100vw;height:100vh;}
    .ui{
      position:fixed;left:12px;top:10px;display:flex;gap:10px;align-items:center;
      color:rgba(255,255,255,.86);
      font:650 12px/1.2 system-ui,-apple-system,Segoe UI,Roboto,Arial;
      user-select:none;
      pointer-events:none;
    }
    .pill{
      padding:7px 10px;border-radius:12px;
      background:rgba(255,255,255,.07);
      border:1px solid rgba(255,255,255,.10);
      backdrop-filter: blur(8px);
    }
    .right{position:fixed;right:12px;top:10px;pointer-events:auto;}
    button{
      appearance:none;border:1px solid rgba(255,255,255,.16);
      background:rgba(255,255,255,.10);
      color:rgba(255,255,255,.92);
      padding:8px 12px;border-radius:12px;
      font:750 12px system-ui,-apple-system,Segoe UI,Roboto,Arial;
      cursor:pointer;
    }
    button:active{transform:translateY(1px)}
  </style>
</head>
<body>
<canvas id="c"></canvas>

<div class="ui">
  <div class="pill" id="status">Fireworks Wall • 10s • HH Finale</div>
</div>
<div class="right">
  <button id="replay">Replay</button>
</div>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha: false });
  const statusEl = document.getElementById("status");
  const replayBtn = document.getElementById("replay");

  // --- HiDPI capped ---
  let W=0,H=0,DPR=1;
  function resize(){
    DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width  = Math.floor(window.innerWidth * DPR);
    canvas.height = Math.floor(window.innerHeight * DPR);
    canvas.style.width="100vw";
    canvas.style.height="100vh";
    ctx.setTransform(DPR,0,0,DPR,0,0);
    W = window.innerWidth;
    H = window.innerHeight;
  }
  window.addEventListener("resize", resize);

  const rand = (a=1,b=0)=>Math.random()*a+b;
  const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
  const lerp=(a,b,t)=>a+(b-a)*t;

  // Palette: warm-gold dominant + rich accents
  const WARM = [
    {h:  36, s: 92, l: 64},
    {h:  42, s: 95, l: 62},
    {h:  28, s: 96, l: 62},
    {h:  18, s: 88, l: 64},
    {h:  50, s: 70, l: 82},
  ];
  const ACCENT = [
    {h: 200, s: 88, l: 66},
    {h: 188, s: 86, l: 62},
    {h: 265, s: 82, l: 70},
    {h: 315, s: 82, l: 68},
  ];
  function pickColor(mode="show"){
    const r = Math.random();
    const useWarm = (mode==="hh") ? (r < 0.92) : (r < 0.78);
    const base = useWarm ? WARM[(Math.random()*WARM.length)|0] : ACCENT[(Math.random()*ACCENT.length)|0];
    return {
      h:(base.h + rand(10,-5)+360)%360,
      s: clamp(base.s + rand(10,-5), 60, 98),
      l: clamp(base.l + rand(10,-6), 52, 86),
    };
  }
  function goldBright(){
    const base = (Math.random()<0.7) ? WARM[0] : (Math.random()<0.7 ? WARM[1] : WARM[4]);
    return {
      h:(base.h+rand(6,-3)+360)%360,
      s: clamp(base.s + rand(8,-4), 55, 98),
      l: clamp(base.l + rand(10,-4), 60, 90),
    };
  }
  function hsl(c,a=1){ return `hsla(${c.h} ${c.s}% ${c.l}% / ${a})`; }

  // ---- State ----
  let rockets, particles, sparks, embers;
  let hhQueue, hhPoints, hhPhase, hhWaveCooldown;
  let startTime, lastTime, frameDt, rafId;
  let running;

  // Budgets (slightly reduced to prevent end-game spikes)
  const MAX_PARTICLES = 13500;
  const MAX_SPARKS    = 3000;
  const MAX_EMBERS    = 2000;
  const MAX_ROCKETS   = 14;

  function roomLeft(arr,max){ return max - arr.length; }

  // ---- Background/trails ----
  let hazeT=0;
  function drawBackground(dt, finaleDim=0){
    hazeT += dt*0.00005;
    ctx.globalCompositeOperation = "source-over";
    // If FPS drops, we fade a bit more to reduce overdraw (adaptive)
    const perf = clamp((frameDt-16)/18, 0, 1); // 0 good, 1 bad
    const fade = lerp(0.18, 0.30, finaleDim*0.7 + perf*0.8);
    ctx.fillStyle = `rgba(5,6,10,${fade})`;
    ctx.fillRect(0,0,W,H);

    const g = ctx.createRadialGradient(W*0.5, H*0.58, Math.min(W,H)*0.10, W*0.5, H*0.58, Math.min(W,H)*0.82);
    g.addColorStop(0, "rgba(0,0,0,0)");
    g.addColorStop(1, `rgba(0,0,0,${0.52+0.12*finaleDim + 0.10*perf})`);
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    ctx.globalAlpha = 0.04*(1-perf);
    ctx.fillStyle = "rgba(255,255,255,0.06)";
    const bandH = 50;
    const y = (Math.sin(hazeT*2*Math.PI)*0.5+0.5) * (H-bandH);
    ctx.fillRect(0, y, W, bandH);
    ctx.globalAlpha = 1;
  }

  function glowDot(x,y,r,color,a){
    ctx.fillStyle = hsl(color, a);
    ctx.beginPath();
    ctx.arc(x,y,r,0,Math.PI*2);
    ctx.fill();
  }

  // Cheap fill to feel "wall" (adaptive count)
  function lightSheet(intensity){
    const perf = clamp((frameDt-16)/18, 0, 1);
    const n = Math.max(3, Math.floor((7 + (Math.random()<0.5?1:0)) * (1 - 0.55*perf)));
    ctx.globalCompositeOperation = "lighter";
    for(let i=0;i<n;i++){
      const c = pickColor("show");
      const x = rand(W*0.98, W*0.01);
      const y = lerp(H*0.70, H*0.45, Math.random());
      const r = lerp(Math.min(W,H)*0.10, Math.min(W,H)*0.22, Math.random());
      glowDot(x,y,r,c, 0.035*intensity*(1-0.35*perf));
    }
    ctx.globalCompositeOperation = "source-over";
  }

  // ---- Spawners ----
  function spawnRocket(x, targetY, style, colorMode="show"){
    if(rockets.length >= MAX_ROCKETS) return;
    rockets.push({
      x, y: H + 14,
      vx: rand(0.7,-0.35),
      vy: -rand(10.2, 12.2),
      ay: 0.12,
      targetY,
      color: pickColor(colorMode),
      style: style || "burst",
      trail: []
    });
  }

  function spawnParticles(x,y, baseColor, count, speedMin, speedMax, lifeMin, lifeMax, drag, gravity, spread=1, kind="main"){
    const room = roomLeft(particles, MAX_PARTICLES);
    if(room <= 0) return;

    // Adaptive: if FPS drops, spawn fewer
    const perf = clamp((frameDt-16)/18, 0, 1);
    const n = Math.min(Math.floor(count * (1 - 0.45*perf)), room);

    for(let i=0;i<n;i++){
      const ang = Math.random()*Math.PI*2;
      const sp = lerp(speedMin, speedMax, Math.random()) * spread;
      particles.push({
        x,y,
        vx: Math.cos(ang)*sp,
        vy: Math.sin(ang)*sp,
        drag,
        g: gravity,
        life: 0,
        maxLife: lerp(lifeMin, lifeMax, Math.random()),
        color: baseColor,
        size: lerp(1.0, 2.2, Math.random()),
        twinkle: Math.random()<0.28,
        kind
      });
    }
  }

  function spawnRing(x,y, baseColor, count, radiusSpeed){
    const room = roomLeft(particles, MAX_PARTICLES);
    if(room <= 0) return;

    const perf = clamp((frameDt-16)/18, 0, 1);
    const n = Math.min(Math.floor(count * (1 - 0.55*perf)), room);

    for(let i=0;i<n;i++){
      const t = i/n * Math.PI*2;
      const sp = radiusSpeed * (0.90 + Math.random()*0.22);
      particles.push({
        x,y,
        vx: Math.cos(t)*sp,
        vy: Math.sin(t)*sp,
        drag: 0.987,
        g: 0.055,
        life: 0,
        maxLife: 820 + Math.random()*360,
        color: baseColor,
        size: 1.6 + Math.random()*1.1,
        twinkle: Math.random()<0.10,
        kind:"ring"
      });
    }
  }

  function spawnCrackle(x,y, baseColor){
    const room = roomLeft(sparks, MAX_SPARKS);
    if(room <= 0) return;

    const perf = clamp((frameDt-16)/18, 0, 1);
    const n = Math.min(Math.floor(110 * (1 - 0.6*perf)), room);

    for(let i=0;i<n;i++){
      const a = Math.random()*Math.PI*2;
      const sp = 2 + Math.random()*7;
      sparks.push({
        x,y,
        vx: Math.cos(a)*sp,
        vy: Math.sin(a)*sp,
        drag: 0.90,
        g: 0.16,
        life: 0,
        maxLife: 300 + Math.random()*220,
        color: baseColor,
        size: 0.8 + Math.random()*1.1
      });
    }
  }

  function spawnEmbers(x,y, baseColor, n=70){
    const room = roomLeft(embers, MAX_EMBERS);
    if(room <= 0) return;

    const perf = clamp((frameDt-16)/18, 0, 1);
    const count = Math.min(Math.floor(n * (1 - 0.55*perf)), room);

    for(let i=0;i<count;i++){
      const ang = Math.random()*Math.PI*2;
      const sp = 0.6 + Math.random()*2.2;
      embers.push({
        x,y,
        vx: Math.cos(ang)*sp,
        vy: Math.sin(ang)*sp,
        drag: 0.992,
        g: 0.03,
        life: 0,
        maxLife: 1100 + Math.random()*800,
        color: baseColor,
        size: 0.7 + Math.random()*0.9,
        twinkle: Math.random()<0.18
      });
    }
  }

  function explode(r){
    const x=r.x, y=r.y;
    const c=r.color;
    const style=r.style;

    ctx.globalCompositeOperation = "lighter";
    glowDot(x,y, 12, c, 0.90);
    glowDot(x,y, 30, c, 0.22);
    ctx.globalCompositeOperation = "source-over";

    if(style==="ring"){
      spawnRing(x,y,c, 360, 7.6);
      spawnParticles(x,y,c, 180, 1.0, 3.8, 650, 1050, 0.989, 0.05, 1, "main");
    } else if(style==="willow"){
      spawnParticles(x,y,c, 560, 1.1, 6.6, 1300, 2200, 0.987, 0.12, 1, "willow");
      spawnEmbers(x,y,c, 120);
    } else if(style==="crackle"){
      spawnParticles(x,y,c, 520, 1.6, 8.2, 850, 1400, 0.988, 0.08, 1, "main");
      if(Math.random()<0.85) spawnCrackle(x,y,c);
      spawnEmbers(x,y,c, 80);
    } else if(style==="peony"){
      spawnParticles(x,y,c, 760, 1.8, 9.8, 980, 1600, 0.987, 0.08, 1, "main");
      spawnRing(x,y,pickColor("show"), 240, 6.2);
      if(Math.random()<0.30) spawnCrackle(x,y,c);
    } else {
      spawnParticles(x,y,c, 620, 1.7, 10.2, 900, 1500, 0.987, 0.08, 1, "main");
      if(Math.random()<0.18) spawnRing(x,y,pickColor("show"), 180, 5.4);
    }

    if(Math.random()<0.16){
      spawnParticles(x,y,pickColor("show"), 180, 1.2, 6.4, 650, 1050, 0.989, 0.05, 1, "accent");
    }
  }

  // ---- Update ----
  function updateRockets(dt){
    for(let i=rockets.length-1;i>=0;i--){
      const r=rockets[i];
      r.vx *= 0.995;
      r.vy += r.ay;
      r.x += r.vx;
      r.y += r.vy;

      r.trail.push([r.x,r.y]);
      if(r.trail.length>14) r.trail.shift();

      if(r.y <= r.targetY || r.vy >= -1.0){
        explode(r);
        rockets.splice(i,1);
      }
    }
  }
  function updateParticles(list, dt){
    for(let i=list.length-1;i>=0;i--){
      const p=list[i];
      p.life += dt;
      if(p.life >= p.maxLife){ list.splice(i,1); continue; }
      p.vx *= p.drag; p.vy *= p.drag;
      p.vy += p.g;
      p.x += p.vx; p.y += p.vy;
      if(p.y > H + 180 || p.x < -180 || p.x > W + 180) list.splice(i,1);
    }
  }

  // ---- Draw ----
  function drawRockets(){
    ctx.globalCompositeOperation = "lighter";
    for(const r of rockets){
      for(let i=0;i<r.trail.length;i++){
        const t=i/(r.trail.length-1);
        const a=0.06 + t*0.22;
        glowDot(r.trail[i][0], r.trail[i][1], 2.0 + t*1.6, r.color, a);
      }
      glowDot(r.x,r.y,3.1,r.color,0.92);
      glowDot(r.x,r.y,8.0,r.color,0.26);
    }
    ctx.globalCompositeOperation = "source-over";
  }

  function drawMainParticles(){
    const perf = clamp((frameDt-16)/18, 0, 1);
    const bloom = 0.10 * (1 - 0.55*perf); // reduce bloom when slow
    ctx.globalCompositeOperation = "lighter";
    for(const p of particles){
      const t = p.life / p.maxLife;
      const a = (t<0.08) ? (t/0.08) : (1 - Math.pow(t, 1.65));
      const tw = p.twinkle ? (0.82 + 0.18*Math.sin((p.life*0.03) + p.x*0.01)) : 1;
      const alpha = clamp(a*tw, 0, 1);
      const r = p.size * (1.0 + (p.kind==="willow" ? t*0.85 : t*0.22));
      glowDot(p.x,p.y,r,p.color,alpha);
      if(bloom > 0.03) glowDot(p.x,p.y,r*3.0,p.color,alpha*bloom);
    }
    ctx.globalCompositeOperation = "source-over";
  }

  function drawSparks(){
    ctx.globalCompositeOperation = "lighter";
    for(const p of sparks){
      const t = p.life / p.maxLife;
      const a = 1 - Math.pow(t, 1.2);
      glowDot(p.x,p.y,p.size,p.color,clamp(a,0,1));
    }
    ctx.globalCompositeOperation = "source-over";
  }

  function drawEmbers(){
    ctx.globalCompositeOperation = "lighter";
    for(const p of embers){
      const t = p.life / p.maxLife;
      const a = (1 - Math.pow(t, 1.18)) * (p.twinkle ? (0.86 + 0.14*Math.sin(p.life*0.02 + p.x*0.01)) : 1);
      glowDot(p.x,p.y,p.size,p.color,clamp(a,0,1));
    }
    ctx.globalCompositeOperation = "source-over";
  }

  // ---- Scheduling ----
  function scheduleShow(t){
    const sec = t/1000;
    const density = clamp(sec/5.8, 0.65, 1.0);
    const baseRate = 1.0 + density*2.6;
    const chance = baseRate * (frameDt/1000);

    if(Math.random() < chance){
      const x = rand(W*0.90, W*0.05);
      const targetY = rand(H*0.52, H*0.14);
      const styles = ["burst","peony","ring","crackle","willow"];
      const style = styles[(Math.random()*styles.length)|0];
      spawnRocket(x, targetY, style, "show");
      if(Math.random() < 0.18*density){
        spawnRocket(x + rand(90,-45), targetY + rand(40,-20), Math.random()<0.5 ? "ring":"peony", "show");
      }
    }

    if(Math.random() < 0.22 * density * (frameDt/1000)){
      const c = pickColor("show");
      const x = rand(W*0.94, W*0.03);
      const y = H*0.93 + rand(10,-5);
      spawnParticles(x,y,c, 110, 1.0, 4.4, 520, 850, 0.989, 0.18, 1, "fountain");
    }
  }

  // ---- HH Finale (pure firework) ----
  function buildHHPoints(){
    const centerX=W*0.5, centerY=H*0.30;
    const size=Math.min(W,H)*0.30;
    const gap=size*0.40;
    const stroke=size*0.20;
    const step=Math.max(16, size*0.12);

    const pts=[];
    function addLine(x1,y1,x2,y2){
      const dx=x2-x1, dy=y2-y1;
      const dist=Math.hypot(dx,dy);
      const n=Math.max(2, Math.floor(dist/step));
      for(let i=0;i<=n;i++){
        const t=i/n;
        pts.push({x:x1+dx*t + rand(2.5,-1.25), y:y1+dy*t + rand(2.5,-1.25)});
      }
    }
    const H1x=centerX-gap, H2x=centerX+gap;
    const top=centerY-size*0.5, bot=centerY+size*0.5, mid=centerY;

    addLine(H1x-stroke, top, H1x-stroke, bot);
    addLine(H1x+stroke, top, H1x+stroke, bot);
    addLine(H1x-stroke, mid, H1x+stroke, mid);

    addLine(H2x-stroke, top, H2x-stroke, bot);
    addLine(H2x+stroke, top, H2x+stroke, bot);
    addLine(H2x-stroke, mid, H2x+stroke, mid);

    return pts;
  }

  function enqueueHHWave(){
    if(!hhPoints) hhPoints = buildHHPoints();
    for(const pt of hhPoints) hhQueue.push(pt);
  }

  function processHHQueue(){
    // budget adapts to FPS
    const budget = frameDt < 18 ? 24 : (frameDt < 24 ? 16 : 10);
    let n = budget;

    while(n-- > 0 && hhQueue.length){
      const pt = hhQueue.pop();
      const c = goldBright();
      spawnParticles(pt.x, pt.y, c, 64, 0.8, 5.2, 1100, 1700, 0.988, 0.055, 1, "HH");
      if(Math.random()<0.16) spawnRing(pt.x, pt.y, c, 46, 3.6);
      if(Math.random()<0.05) spawnCrackle(pt.x, pt.y, c);
      if(Math.random()<0.16) spawnEmbers(pt.x, pt.y, c, 16);
    }

    if(hhQueue.length===0 && hhPhase>0){
      hhPhase--;
      hhWaveCooldown = 12;
    }
  }

  // Finale wall effects (adaptive throttling)
  let wallTimer=0, fanTimer=0;
  function finaleWall(dt){
    const perf = clamp((frameDt-16)/18, 0, 1);
    const wallInterval = lerp(120, 210, perf); // slower when laggy
    const fanInterval  = lerp(170, 280, perf);

    wallTimer += dt;
    if(wallTimer > wallInterval){
      wallTimer = 0;
      spawnRocket(rand(W*0.94, W*0.03), rand(H*0.24, H*0.10), "willow", "hh");
      if(Math.random() < (0.55*(1-perf))) spawnRocket(rand(W*0.94, W*0.03), rand(H*0.26, H*0.12), "peony", "hh");
    }

    fanTimer += dt;
    if(fanTimer > fanInterval){
      fanTimer = 0;
      const left = Math.random()<0.5;
      const x = left ? W*0.16 : W*0.84;
      const y = H*0.92;
      const c = pickColor("hh");

      const room = roomLeft(particles, MAX_PARTICLES);
      const baseN = 190;
      const n = Math.min(Math.floor(baseN*(1-0.55*perf)), Math.max(0, room));
      for(let i=0;i<n;i++){
        const base = left ? -Math.PI*0.06 : -Math.PI*0.94;
        const cone = Math.PI*0.22;
        const ang = base + (Math.random()*2-1)*cone;
        const sp = 2.2 + Math.random()*6.2;
        particles.push({
          x,y,
          vx: Math.cos(ang)*sp,
          vy: Math.sin(ang)*sp,
          drag: 0.989,
          g: 0.16,
          life: 0,
          maxLife: 620 + Math.random()*520,
          color: c,
          size: 1.1 + Math.random()*1.7,
          twinkle: Math.random()<0.22,
          kind:"fan"
        });
      }
      if(Math.random() < 0.35*(1-perf)) spawnCrackle(x + rand(70,-35), y - rand(180,70), c);
    }
  }

  function triggerFinale(){
    statusEl.textContent = "FINALe • “HH” • Fireworks Wall";
    hhQueue.length = 0;
    hhPoints = buildHHPoints();
    hhPhase = 1;
    hhWaveCooldown = 0;
    enqueueHHWave();

    for(let i=0;i<3;i++){
      spawnRocket(W*(0.40 + 0.20*Math.random()), rand(H*0.26, H*0.12), "peony", "hh");
    }
  }

  // ---- Replay ----
  function resetAndStart(){
    resize();
    finaleStarted = false;

    rockets = [];
    particles = [];
    sparks = [];
    embers = [];
    hhQueue = [];
    hhPoints = null;
    hhPhase = 0;
    hhWaveCooldown = 0;
    wallTimer = 0;
    fanTimer = 0;
    hazeT = 0;

    startTime = null;
    lastTime = null;
    frameDt = 16.7;
    running = true;

    for(let i=0;i<4;i++){
      spawnRocket(rand(W*0.75, W*0.12), rand(H*0.36, H*0.18), "peony", "show");
    }

    statusEl.textContent = "Fireworks Wall • 10s • HH Finale";
    if(rafId) cancelAnimationFrame(rafId);
    rafId = requestAnimationFrame(frame);
  }
  replayBtn.addEventListener("click", resetAndStart);

  let finaleStarted = false;
  function frame(now){
    if(!running) return;

    if(startTime==null){ startTime=now; lastTime=now; }
    frameDt = clamp(now-lastTime, 8, 50);
    lastTime = now;

    const t = now - startTime;
    const inFinale = t >= 8200;
    const finaleDim = inFinale ? clamp((t-8200)/520, 0, 1) : 0;

    drawBackground(frameDt, finaleDim);
    lightSheet(inFinale ? 0.70 : 1.0);

    if(!inFinale){
      scheduleShow(t);
      if(t>3500 && Math.random() < 0.24*(frameDt/1000)){
        spawnRocket(rand(W*0.88, W*0.06), rand(H*0.32, H*0.14), "ring", "show");
      }
    } else {
      if(!finaleStarted){
        finaleStarted = true;
        triggerFinale();
      }

      // further reduce background launches when laggy
      const perf = clamp((frameDt-16)/18, 0, 1);
      if(Math.random() < (0.10*(1-perf))*(frameDt/1000)){
        spawnRocket(rand(W*0.86, W*0.07), rand(H*0.30, H*0.16), "ring", "hh");
      }

      finaleWall(frameDt);

      if(hhWaveCooldown > 0) hhWaveCooldown--;
      else if(hhQueue.length > 0) processHHQueue();
      else if(hhPhase > 0){
        enqueueHHWave();
      }
    }

    updateRockets(frameDt);
    updateParticles(particles, frameDt);
    updateParticles(sparks, frameDt);
    updateParticles(embers, frameDt);

    drawRockets();
    drawMainParticles();
    drawSparks();
    drawEmbers();

    const sec = clamp(t/1000, 0, 10).toFixed(1);
    if(!inFinale) statusEl.textContent = `Fireworks Wall • ${sec}s • HH Finale`;
    else statusEl.textContent = `FINALe • ${sec}s • “HH”`;

    if(t > 10000){
      if(t > 11300){
        running = false;
        statusEl.textContent = "Done • Tap Replay";
        return;
      }
    }

    rafId = requestAnimationFrame(frame);
  }

  resetAndStart();
})();
</script>
</body>
</html>
